'use strict';

var _templateObject = _taggedTemplateLiteral(['\n      Cypress executable not found at: ', '\n    '], ['\n      Cypress executable not found at: ', '\n    ']),
    _templateObject2 = _taggedTemplateLiteral(['\n              Smoke test returned wrong code.\n\n              Command was: ', '\n\n              Returned: ', '\n            '], ['\n              Smoke test returned wrong code.\n\n              Command was: ', '\n\n              Returned: ', '\n            ']),
    _templateObject3 = _taggedTemplateLiteral(['\n  It looks like this is your first time using Cypress: ', '\n  '], ['\n  It looks like this is your first time using Cypress: ', '\n  ']),
    _templateObject4 = _taggedTemplateLiteral(['\n        ', ' You have set the environment variable: ', '', ':\n        \n              This overrides the default Cypress binary path used.\n        '], ['\n        ', ' You have set the environment variable: ', '', ':\n        \n              This overrides the default Cypress binary path used.\n        ']),
    _templateObject5 = _taggedTemplateLiteral(['\n          The supplied binary path is not executable\n          '], ['\n          The supplied binary path is not executable\n          ']),
    _templateObject6 = _taggedTemplateLiteral(['\n      \n      \n      ', ' Warning: Binary version ', ' does not match the expected package version ', '\n\n        These versions may not work properly together.\n      '], ['\n      \n      \n      ', ' Warning: Binary version ', ' does not match the expected package version ', '\n\n        These versions may not work properly together.\n      ']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _ = require('lodash');
var cp = require('child_process');
var chalk = require('chalk');
var Listr = require('listr');
var debug = require('debug')('cypress:cli');
var verbose = require('@cypress/listr-verbose-renderer');

var _require = require('common-tags'),
    stripIndent = _require.stripIndent;

var Promise = require('bluebird');
var logSymbols = require('log-symbols');

var _require2 = require('../errors'),
    throwFormErrorText = _require2.throwFormErrorText,
    errors = _require2.errors;

var fs = require('../fs');
var util = require('../util');
var logger = require('../logger');
var xvfb = require('../exec/xvfb');
var state = require('./state');

var verificationError = function verificationError(message) {
  return _.extend(new Error(''), { name: '', message: message, isVerificationError: true });
};

var xvfbError = function xvfbError(message) {
  return _.extend(new Error(''), { name: '', message: message, isXvfbError: true });
};

var isMissingExecutable = function isMissingExecutable(binaryDir) {
  var executable = state.getPathToExecutable(binaryDir);
  debug('checking if executable exists', executable);
  return fs.pathExistsAsync(executable).then(function (exists) {
    if (!exists) {
      return throwFormErrorText(errors.missingApp(binaryDir))(stripIndent(_templateObject, chalk.cyan(executable)));
    }
  });
};

var runSmokeTest = function runSmokeTest(binaryDir) {
  debug('running smoke test');
  var stderr = '';
  var stdout = '';
  var cypressExecPath = state.getPathToExecutable(binaryDir);
  debug('using Cypress executable %s', cypressExecPath);

  // TODO switch to execa for this?
  var spawn = function spawn() {
    return new Promise(function (resolve, reject) {
      var random = _.random(0, 1000);
      var args = ['--smoke-test', '--ping=' + random];
      var smokeTestCommand = cypressExecPath + ' ' + args.join(' ');
      debug('smoke test command:', smokeTestCommand);
      var child = cp.spawn(cypressExecPath, args);

      child.stderr.on('data', function (data) {
        stderr += data.toString();
      });

      child.stdout.on('data', function (data) {
        stdout += data.toString();
      });

      child.on('error', reject);

      child.on('close', function (code) {
        if (code === 0) {
          var smokeTestReturned = stdout.trim();
          debug('smoke test output "%s"', smokeTestReturned);

          if (!util.stdoutLineMatches(String(random), smokeTestReturned)) {
            return reject(new Error(stripIndent(_templateObject2, smokeTestCommand, smokeTestReturned)));
          }

          return resolve();
        }

        reject(verificationError(stderr));
      });
    });
  };

  var onXvfbError = function onXvfbError(err) {
    debug('caught xvfb error %s', err.message);
    throw xvfbError('Caught error trying to run XVFB: "' + err.message + '"');
  };

  var needsXvfb = xvfb.isNeeded();
  debug('needs XVFB?', needsXvfb);

  if (needsXvfb) {
    return xvfb.start().catch(onXvfbError).then(spawn).finally(function () {
      return xvfb.stop().catch(onXvfbError);
    });
  } else {
    return spawn();
  }
};

function testBinary(version, binaryDir) {
  debug('running binary verification check', version);

  logger.log(stripIndent(_templateObject3, chalk.cyan(version)));

  logger.log();

  // if we are running in CI then use
  // the verbose renderer else use
  // the default
  var rendererOptions = {
    renderer: util.isCi() ? verbose : 'default'
  };

  var tasks = new Listr([{
    title: util.titleize('Verifying Cypress can run', chalk.gray(binaryDir)),
    task: function task(ctx, _task) {
      debug('clearing out the verified version');
      return state.clearBinaryStateAsync(binaryDir).then(function () {
        return Promise.all([runSmokeTest(binaryDir), Promise.resolve().delay(1500)] // good user experience
        );
      }).then(function () {
        debug('write verified: true');
        return state.writeBinaryVerifiedAsync(true, binaryDir);
      }).then(function () {
        util.setTaskTitle(_task, util.titleize(chalk.green('Verified Cypress!'), chalk.gray(binaryDir)), rendererOptions.renderer);
      }).catch({ isXvfbError: true }, throwFormErrorText(errors.missingXvfb)).catch({ isVerificationError: true }, throwFormErrorText(errors.missingDependency));
    }
  }], rendererOptions);

  return tasks.run();
}

var maybeVerify = function maybeVerify(installedVersion, binaryDir) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return state.getBinaryVerifiedAsync(binaryDir).then(function (isVerified) {

    debug('is Verified ?', isVerified);

    var shouldVerify = !isVerified;
    // force verify if options.force
    if (options.force) {
      debug('force verify');
      shouldVerify = true;
    }

    if (shouldVerify) {
      return testBinary(installedVersion, binaryDir).then(function () {
        if (options.welcomeMessage) {
          logger.log();
          logger.log('Opening Cypress...');
        }
      });
    }
  });
};

var start = function start() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  debug('verifying Cypress app');

  var packageVersion = util.pkgVersion();
  var binaryDir = state.getBinaryDir(packageVersion);

  _.defaults(options, {
    force: false,
    welcomeMessage: true
  });

  var checkEnvVar = function checkEnvVar() {
    debug('checking environment variables');
    if (process.env.CYPRESS_RUN_BINARY) {
      var envBinaryPath = process.env.CYPRESS_RUN_BINARY;
      debug('CYPRESS_RUN_BINARY exists, =', envBinaryPath);
      logger.log(stripIndent(_templateObject4, chalk.yellow('Note:'), chalk.white('CYPRESS_RUN_BINARY='), chalk.cyan(envBinaryPath)));
      logger.log();

      return util.isExecutableAsync(envBinaryPath).then(function (isExecutable) {
        debug('CYPRESS_RUN_BINARY is executable? :', isExecutable);
        if (!isExecutable) {
          return throwFormErrorText(errors.CYPRESS_RUN_BINARY.notValid(envBinaryPath))(stripIndent(_templateObject5));
        }
      }).then(function () {
        return state.parseRealPlatformBinaryFolderAsync(envBinaryPath);
      }).then(function (envBinaryDir) {
        if (!envBinaryDir) {
          return throwFormErrorText(errors.CYPRESS_RUN_BINARY.notValid(envBinaryPath))();
        }
        debug('CYPRESS_RUN_BINARY has binaryDir:', envBinaryDir);

        binaryDir = envBinaryDir;
      }).catch({ code: 'ENOENT' }, function (err) {
        return throwFormErrorText(errors.CYPRESS_RUN_BINARY.notValid(envBinaryPath))(err.message);
      });
    }
    return Promise.resolve();
  };

  return checkEnvVar().then(function () {
    return isMissingExecutable(binaryDir);
  }).tap(function () {
    return debug('binaryDir is ', binaryDir);
  }).then(function () {
    return state.getBinaryPkgVersionAsync(binaryDir);
  }).then(function (binaryVersion) {

    if (!binaryVersion) {
      debug('no Cypress binary found for cli version ', packageVersion);
      return throwFormErrorText(errors.missingApp(binaryDir))('\n      Cannot read binary version from: ' + chalk.cyan(state.getBinaryPkgPath(binaryDir)) + '\n    ');
    }

    debug('Found binary version ' + chalk.green(binaryVersion) + ' installed in: ' + chalk.cyan(binaryDir));

    if (binaryVersion !== packageVersion) {
      // warn if we installed with CYPRESS_INSTALL_BINARY or changed version
      // in the package.json
      logger.log('Found binary version ' + chalk.green(binaryVersion) + ' installed in: ' + chalk.cyan(binaryDir));
      logger.log();
      logger.warn(stripIndent(_templateObject6, logSymbols.warning, chalk.green(binaryVersion), chalk.green(packageVersion)));

      logger.log();
    }

    return maybeVerify(binaryVersion, binaryDir, options);
  }).catch(function (err) {
    if (err.known) {
      throw err;
    }

    return throwFormErrorText(errors.unexpected)(err.stack);
  });
};

module.exports = {
  start: start,
  maybeVerify: maybeVerify
};